using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace RazorComponentRenderer.Generators;

[Generator]
public class ComponentParametersGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor LogExceptionDiagnostic = new(
        id: "CPG0001",
        title: "Component Parameter ComponentParametersGenerator Exception",
        messageFormat: "An exception occurred in Component Parameter ComponentParametersGenerator: {0}",
        category: "SourceGeneration",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "Logs exceptions caught during source generation to the IDE's error list."
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var razorFiles = context.AdditionalTextsProvider
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Where(((AdditionalText file, AnalyzerConfigOptionsProvider options) combined) => combined.file.Path.EndsWith(".razor", StringComparison.OrdinalIgnoreCase));

        var classNodeProvider = razorFiles
            .Select((combined, cancellationToken) =>
            {
                var (file, optionsProvider) = combined;
                var options = optionsProvider.GetOptions(file);


                var text = file.GetText(cancellationToken);
                var content = text is null ? string.Empty : text.ToString();

                var classNamespace = ExtractNamespaceDirective(content);
                if (classNamespace == null)
                {
                    options.TryGetValue("build_property.RootNamespace", out var rootNamespace);
                    classNamespace = CalculateRazorNamespace(file.Path, rootNamespace);
                }

                var className = Path.GetFileNameWithoutExtension(file.Path);
                if (className.StartsWith("_", StringComparison.Ordinal))
                    return ((ClassDeclarationSyntax?)null, (string?)null);

                var fullClass = ExtractAndWrapCodeBlocks(content, className);

                var tree = CSharpSyntaxTree.ParseText(fullClass);
                var root = tree.GetRoot();

                var classDeclaration = root.DescendantNodes().OfType<ClassDeclarationSyntax>().FirstOrDefault() ?? SyntaxFactory.ClassDeclaration(className);

                return (classDeclaration, classNamespace);
            });

        context.RegisterSourceOutput(classNodeProvider, (spc, classNodes) =>
        {
            var (classDeclaration, classNamespace) = classNodes;
            if (classDeclaration is null || classNamespace is null) return;

            var className = classDeclaration.Identifier.ToString();
            var properties = classDeclaration.Members
                .OfType<PropertyDeclarationSyntax>()
                .Where(prop =>
                    prop.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)) &&
                    prop.AttributeLists
                        .SelectMany(a => a.Attributes)
                        .Any(attr => attr.Name.ToString() == "Parameter" || attr.Name.ToString().EndsWith(".Parameter"))
                )
                .ToList();
            var codeBuilder = new StringBuilder();
            codeBuilder.AppendLine($$"""
                                     #nullable enable
                                     // <auto-generated />
                                     using System;
                                     using System.Collections.Generic;
                                     using Microsoft.AspNetCore.Components;
                                     using RazorComponentRenderer;
                                     namespace {{classNamespace}}
                                     {
                                         public partial class {{className}}
                                         {
                                             public static ComponentParameters<{{className}}> CreateComponentParameters({{string.Join(", ", properties.Select(x => $"{x.Type.ToString()} {char.ToLowerInvariant(x.Identifier.Text[0]) + x.Identifier.Text.Substring(1)}"))}}) => new(
                                                 new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase)
                                                 {
                                                     {{string.Join(", ", properties.Select(x => $"[nameof({char.ToLowerInvariant(x.Identifier.Text[0]) + x.Identifier.Text.Substring(1)})] = {char.ToLowerInvariant(x.Identifier.Text[0]) + x.Identifier.Text.Substring(1)}"))}}
                                                 }
                                             );
                                         }
                                     }    
                                     """);

            try
            {
                spc.AddSource(
                    Path.GetFileNameWithoutExtension(className) + "Props.g.cs",
                    SourceText.From(codeBuilder.ToString(), Encoding.UTF8)
                );
            }
            catch (Exception e)
            {
                spc.ReportDiagnostic(Diagnostic.Create(LogExceptionDiagnostic, Location.None, e.ToString()));
            }
        });
    }

    private static string CalculateRazorNamespace(string filePath, string? rootNamespace)
    {
        var baseNamespace = rootNamespace ?? "App";
        var relativePath = GetRelativeNamespacePath(filePath, baseNamespace);
        return string.IsNullOrEmpty(relativePath) ? baseNamespace : $"{baseNamespace}.{relativePath}";
    }

    private static string GetRelativeNamespacePath(string filePath, string rootNamespace)
    {
        var directory = Path.GetDirectoryName(filePath);
        if (string.IsNullOrEmpty(directory)) return string.Empty;

        var parts = directory.Split([Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar], StringSplitOptions.RemoveEmptyEntries);

        var projectIndex = Array.FindIndex(parts, part =>
            string.Equals(part, rootNamespace, StringComparison.OrdinalIgnoreCase));

        if (projectIndex >= 0 && projectIndex < parts.Length - 1)
        {
            var namespaceParts = parts.Skip(projectIndex + 1);
            return string.Join(".", namespaceParts);
        }

        if (parts.Length >= 2)
        {
            return string.Join(".", parts.Skip(parts.Length - 2));
        }

        return parts.Length > 0 ? parts[parts.Length - 1] : string.Empty;
    }

    private static string? ExtractNamespaceDirective(string content)
    {
        var match = Regex.Match(content, @"@namespace\s+([^\r\n]+)");
        return match.Success ? match.Groups[1].Value.Trim() : null;
    }

    private static string ExtractAndWrapCodeBlocks(string razorContent, string className)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"class {className}");
        sb.AppendLine("{");

        var index = 0;

        while (index < razorContent.Length)
        {
            var codeStart = razorContent.IndexOf("@code", index, StringComparison.OrdinalIgnoreCase);
            if (codeStart == -1) break;

            var braceStart = razorContent.IndexOf('{', codeStart);
            if (braceStart == -1) break;

            var braceCount = 0;
            var end = braceStart;

            for (; end < razorContent.Length; end++)
            {
                switch (razorContent[end])
                {
                    case '{':
                        braceCount++;
                        break;
                    case '}':
                        braceCount--;
                        break;
                }

                if (braceCount != 0) continue;
                var inner = razorContent.Substring(braceStart + 1, end - braceStart - 1).Trim();
                sb.AppendLine(inner);
                index = end + 1;
                break;
            }

            if (braceCount != 0) break; // unbalanced, stop parsing
        }

        sb.AppendLine("}");
        return sb.ToString();
    }
}